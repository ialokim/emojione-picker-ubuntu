#!/usr/bin/python2.7
# -*- coding: UTF-8 -*-
#

import os
import subprocess
import time
import socket
import sys
import json
from os.path import expanduser
import signal
from collections import OrderedDict
import re

# Fix enconding in older Python versions
reload(sys)
sys.setdefaultencoding('utf8')

# Import GTK
from gi import require_version
require_version('AppIndicator3', '0.1')
require_version('Gtk', '3.0')
require_version('Notify', '0.7')
from gi.repository import GLib, Gtk, GObject, Gdk, Notify, GdkPixbuf
from gi.repository import AppIndicator3 as appindicator

# Where is the data?
directories = [expanduser("~") + "/.local/share/emojione-picker-dev", "/usr/local/share/emojione-picker-dev", "/usr/share/emojione-picker-dev", os.path.dirname(os.path.realpath(__file__))]
for d in directories:
    if os.path.isdir(d):
        directory = d;
        break

# Categories definitions
categories = ["recent", "people", "food", "nature", "objects", "activity", "travel", "flags", "symbols"]

# Settings handling
default_settings = settings = { 
    "toned": -1,
    "notifications": True,
    "lowend": False,
    "recent": 20,
    "paste": False
}
configpath = expanduser("~") + "/.config/emojione-picker-dev"
os.path.isdir(configpath) or os.mkdir(configpath)

sockname = '/tmp/emojisocket.' + str(os.getuid()) + os.environ['DISPLAY']

builder = Gtk.Builder()

def handle_sock_signal(sock, *args):
    GLib.io_add_watch(sock, GLib.IO_IN, handle_sock_signal)
    conn, addr = sock.accept()
    conn.close()
    open_search_window('','')

def exit(self, w):
    sys.exit()

def open_settings_window(self, w):
    global settings
    builder.add_from_file(directory + "/assets/settings.glade")
    builder.connect_signals(SettingsButtonHandler())
    settings_window = builder.get_object("settings_window")
    settings_window.show_all()
    settings_window.present()
    settings_window.grab_focus()
    # Apply settings
    builder.get_object("combo_toned").set_active(settings["toned"]+1)
    builder.get_object("check_notifications").set_active(settings["notifications"])
    builder.get_object("check_lowend").set_active(settings["lowend"])
    builder.get_object("recent").set_value(settings["recent"])
    builder.get_object("check_paste").set_active(settings["paste"])

class SettingsButtonHandler:
    def onButtonPressed(self, button):
        apply_settings()
        button.get_parent_window().destroy()
    def onToggled(self,button):
        if builder.get_object("check_paste").get_active() == True:
            builder.get_object("check_notifications").set_sensitive(False)
        else:
            builder.get_object("check_notifications").set_sensitive(True)

def apply_settings():
    global settings
    # Get settings from dialog
    settings = { 
        "toned": builder.get_object("combo_toned").get_active()-1,
        "notifications": builder.get_object("check_notifications").get_active(),
        "lowend": builder.get_object("check_lowend").get_active(),
        "recent": builder.get_object("recent").get_value_as_int(),
        "paste": builder.get_object("check_paste").get_active()
    }
    # Save settings to file
    save_settings()
    # Reload app to apply new settings - FIXME: This is ugly and slow, could be much better
    os.unlink(sockname)
    os.execv(__file__, sys.argv)

def save_settings():
    global settings
    with open(configfile, 'w') as outfile:
        json.dump(settings, outfile)

# Search feature
searchbuilder = None
search_window = None
def open_search_window(self, w):
    global searchbuilder
    global search_window
    # Build window only once
    try:
        search_window.show_all()
        search_window.present()
        search_window.grab_focus()
    except:
        # Build window
        searchbuilder = Gtk.Builder()
        searchbuilder.add_from_file(directory + "/assets/chooser.glade")
        searchbuilder.connect_signals(SearchHandler())
        search_window = searchbuilder.get_object("search_window")
        search_window.show_all()
        search_window.present()
        search_window.grab_focus()

        # Put recent icons by default
        iconstore = searchbuilder.get_object("iconstore")
        global sorted_recent, searchresults
        for i in sorted_recent:
            emoji_name = sorted_recent[i]["name"]
            emoji_image = get_emoji_pixbuf(sorted_recent[i], 24)
            emoji_code = sorted_recent[i]["unicode"]
            iconstore.append([emoji_image, emoji_code, emoji_name])
            searchresults = []
        for i in sorted_recent.keys():
            searchresults.append(sorted_recent[i])

    return

searchresults = None
selectionChanged = False
class SearchHandler:
    def onSearchChanged(self, search):
        global searchresults
        search = searchbuilder.get_object("search").get_text()
        iconstore = searchbuilder.get_object("iconstore")
        iconstore.clear()
        if search == "":
            # No search? Put recent icons
            global sorted_recent
            for i in sorted_recent:
                emoji_name = sorted_recent[i]["name"]
                emoji_image = get_emoji_pixbuf(sorted_recent[i], 24)
                emoji_code = sorted_recent[i]["unicode"]
                iconstore.append([emoji_image, emoji_code, emoji_name])
            searchresults = []
            for i in sorted_recent.keys():
                searchresults.append(sorted_recent[i])
            return
        numfound=0
        searchresults = []
        for i in sorted_data:
            match = False
            for keyword in sorted_data[i]["keywords"]:
                if keyword.find(search)>-1:
                    match = True
            if sorted_data[i]["name"].find(search)>-1:
                match = True
            if match == True:
                numfound += 1
                if numfound > 50:
                    return
                searchresults.append(sorted_data[i])
                emoji_name = sorted_data[i]["name"]
                emoji_image = get_emoji_pixbuf(sorted_data[i], 24)
                emoji_code = sorted_data[i]["unicode"]
                iconstore.append([emoji_image, emoji_code, emoji_name])
    def onIconActivated(self, icon, index):
        global searchresults
        item_response(self, searchresults[int(index.to_string())])
        icon.get_parent_window().hide()
    def onSelectionChanged(self, data):
        global selectionChanged
        selectionChanged = True
    def onKeyReleased(self, window, event):
        global selectionChanged
        if event.keyval == Gdk.KEY_Escape:
            window.hide()
        elif event.keyval == Gdk.KEY_Down:
            searchbuilder.get_object("iconview").grab_focus()
        elif event.keyval == Gdk.KEY_Up and selectionChanged == False:
            searchbuilder.get_object("search").grab_focus()
        selectionChanged = False
    def onOutFocus(self, window, data):
        window.hide()

# Load settings at startup
configfile = configpath + "/settings.json"
if os.path.isfile(configfile):
  with open(configfile) as settings_json_file:
      try:
          settings = json.load(settings_json_file)
      except:
          save_settings()
      
else:
    save_settings()

for k in default_settings.keys():
    if not k in settings:
        settings[k] = default_settings[k]
  
# Load recent emojis at startup
recentfile = configpath + "/recent.json"
if os.path.isfile(recentfile):
    with open(recentfile) as recent_json_file:
        recent = json.load(recent_json_file)
    recentindex = 0
    for k in recent.keys():
        if(int(recent[k]["recent_order"])>recentindex):
            recentindex = int(recent[k]["recent_order"])
    recentindex += 1
else:
    recent = dict()
    recentindex = 0

# If using lowend, load lowend information
if settings["lowend"] == True:
    lowendfile = directory + "/assets/lowend.json"
    if os.path.isfile(lowendfile):
        with open(lowendfile) as lowend_json_file:
            lowend = json.load(lowend_json_file)

# Refresh recent icons submenu
sorted_recent = None
def refresh_recent_submenu():
    global recent, recent_items, sorted_recent

    # Rearrange data
    def orderfunc(tup):
        key, d = tup
        return -int(d["recent_order"])
    sorted_recent = sorted(recent.items(), key=orderfunc)
    sorted_recent = OrderedDict(sorted_recent)

    # Refresh icons
    i = 0
    for key in sorted_recent:
        if i >= settings["recent"]:
            break
        pixbuf = get_emoji_pixbuf(sorted_recent[key])
        img = Gtk.Image.new_from_pixbuf(pixbuf)
        recent_items[i].set_image(img)
        recent_items[i].set_label(get_emoji_name(sorted_recent[key]).title())
        recent_items[i].show()
        if ("recent_" + str(i)) in signals.keys():
            recent_items[i].disconnect(signals["recent_" + str(i)])
        signals["recent_" + str(i)] = recent_items[i].connect("activate", item_response, sorted_recent[key])
        i = i + 1

# Type character using xdootool [Experimental]
def type_xdotool(text):
    time.sleep(0.1)
    subprocess.Popen(["xdotool", "type", text])
    return False # Glib.idle_add needs this

# Click response
def item_response(self, w):
    global recentindex, recent
    
    # If this is a toned item with submenu, do nothing
    try:
        if self.get_submenu() != None:
            return
    except AttributeError:
        pass

    # Copy character to clipboard or write it
    output = w["emoji"]
    
    if settings["paste"]==True:
        GLib.idle_add(type_xdotool,output)
    else:
        clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        GLib.idle_add(clipboard.set_text,output, -1)

    # Show notification
    if settings["notifications"]==True:
        if settings["paste"]==False:
            n = Notify.Notification.new(get_emoji_name(w).title(), "Emoji is now in the clipboard. Paste it wherever you want!", get_emoji_icon(w))
            n.show()

    # Remove item from recent if already present
    try:
        for k in recent.keys():
            if recent[k]["order"] == w["order"]:
                del recent[k]
    except ValueError:
        pass

    # Store item on recent
    w["recent_order"] = recentindex
    recentindex = recentindex + 1
    recent.update({w["order"]:w})

    # Remove older items if recent is too big
    if len(recent) > settings["recent"]:
        biggestindex = 0
        for k in recent.keys():
            if recent[k]["recent_order"] > biggestindex:
                biggestindex = recent[k]["recent_order"]
        nextbiggest = biggestindex
        for i in range (1, settings["recent"]):
            nextbiggest_candidate = 0
            for k in recent.keys():
                if recent[k]["recent_order"] < nextbiggest and recent[k]["recent_order"] > nextbiggest_candidate:
                    nextbiggest_candidate = recent[k]["recent_order"]
            nextbiggest = nextbiggest_candidate
        minindex = nextbiggest
        for k in recent.keys():
            if recent[k]["recent_order"] < minindex:
                del recent[k]

    # Save recentfile
    with open(recentfile, 'w') as outfile:
        json.dump(recent, outfile)

    # Refresh recent icons submenu
    GLib.idle_add(refresh_recent_submenu)  

def get_emoji_group(code):
    for key in groups_data:
        if code in groups_data[key]["unicodes"]:
            return key
    return False

def get_emoji_name(emoji):
    if "annotation" in emoji:
        return emoji["annotation"]
    return emoji["name"]
    
def get_emoji_icon(emoji):
    return directory + "/assets/png/" + emoji["hexcode"].lower() + ".png"

def get_emoji_pixbuf(emoji, size = None):
    return get_icon_pixbuf(get_emoji_icon(emoji))
    
def fix_emoji_hexcode(emoji):
    hexcodes = emoji["hexcode"].split('-')
    if len(hexcodes) > 1:
        hexcode = ""
        for h in hexcodes:
            if h != "200D" and h != "FE0F":
                hexcode += "-" + h
        emoji["hexcode"] = hexcode[1:]
    return emoji

def get_icon_pixbuf(path, size = None):
    if size is None:
        # Get proper icon sizes
        size = Gtk.IconSize.lookup(Gtk.IconSize.MENU)[1]
    return GdkPixbuf.Pixbuf.new_from_file_at_size(path, size, size)

def build_emoji_item(emoji, name = None):
    if name is None:
		name = get_emoji_name(emoji)
    
    try:
        pixbuf = get_emoji_pixbuf(emoji)
        img = Gtk.Image.new_from_pixbuf(pixbuf)
    except:
        img = Gtk.Image()
        print ("Icon for '%s' could not be found: %s" % (name, emoji["hexcode"]))
    
    return build_menu_item(name, img)

def build_menu_item(name, img):
    item = Gtk.ImageMenuItem(name.title())
    item_settings = item.get_settings()
    item_settings.set_property('gtk-menu-images', True)
    GLib.idle_add(item.set_image, img)
    GLib.idle_add(item.show)
    return item
    

def build_group_menu(item):
    menu = Gtk.Menu()
    GLib.idle_add(item.set_submenu, menu)
    return menu
    
def replace_subgroup_name(subgroup_name):
    matrix = {
        'cat-face': 'face-cat',
        'monkey-face': 'face-monkey',
        'sky-weather': 'sky & weather',
        'award-medal': 'award medal',
        'musical-instrument': 'music-instrument',
        'light-video': 'light & video',
        'book-paper': 'book & paper',
        'other-object': 'other',
        'transport-sign': 'transport sign',
        'av-symbol': 'audio & video',
        'other-symbol': 'other',
        'flag': 'other',
        'other-symbol': 'other',
        'other-symbol': 'other',
        'flag': 'misc',
        'country-flag': 'country',
        'subdivision-flag': 'country'
    }
    if subgroup_name in matrix:
        return matrix[subgroup_name]
    return subgroup_name
        

if __name__ == "__main__":
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(sockname)
    except:

        # Calling GObject.threads_init() is not needed for PyGObject 3.10.2+
        GObject.threads_init()

        # Initialize notifications
        Notify.init("emojione-picker-dev")

        # Create the main menu
        menu = Gtk.Menu()

        # Create indicator
        ind = appindicator.Indicator.new("emojione-picker-dev", directory + "/assets/icon-default.svg", appindicator.IndicatorCategory.APPLICATION_STATUS)
        ind.set_status(appindicator.IndicatorStatus.ACTIVE)

        # If there is a icon present in the theme, use it!
        try:
          icons = Gtk.IconTheme.get_default()
          icon = icons.load_icon("emojione-picker-dev", Gtk.IconSize.MENU, 0)
          ind.set_icon("emojione-picker-dev")
        except:
          pass

        # Load groups and icons definition and rearrange them in order
        with open(directory + "/assets/groups.json") as groups_file:
            groups_data = json.load(groups_file)
        with open(directory + "/assets/emoji.json") as json_file:
            json_data = json.load(json_file)
            def orderfunc(d):
                return int(d["order"])
            sorted_data = sorted(json_data, key=orderfunc)
        with open(directory + "/assets/subgroups.json") as subgroups_file:
            subgroups_data = json.load(subgroups_file)

        # Load icons into menu items
        group_items = {}
        group_menus = {}
        signals = {}
        
        # Add every single emoji to menu
        for key, emoji in enumerate(sorted_data):
            emoji_group = str(emoji["group"])
            emoji_subgroup = str(emoji["subgroup"])
            
            emoji = fix_emoji_hexcode(emoji)
            
            group_name = groups_data["groups"][emoji_group]
            group_key = '0-' + group_name
            if group_key not in group_items:
                # First emoji of this group, build the group
                item = build_emoji_item(emoji, group_name.replace('-', ' & '))
                submenu = build_group_menu(item)
                group_items[group_key] = item
                group_menus[group_key] = submenu
            
            subgroup_name = groups_data["subgroups"][emoji_subgroup]
            subgroup_name = replace_subgroup_name(subgroup_name)
            subgroup_key = group_key + '-' + subgroup_name
            if subgroup_key not in group_items:
                # First emoji of this subgroup, build the subgroup
                
                # Some subgroups are composed of two keywords, group them by the first one in parentgroup
                subgroups = subgroup_name.split('-')
                if len(subgroups) > 1: # TODO: implement setting
                    parentgroup_name = subgroups[0]
                    parentgroup_key = group_key + '-' + parentgroup_name
                    if parentgroup_key not in group_items:
                        # First emoji of this parentgroup, build the parentgroup
                        parentgroup_item = build_emoji_item(emoji, parentgroup_name)
                        parentgroup_submenu = build_group_menu(parentgroup_item)
                        GLib.idle_add(group_menus[group_key].append, parentgroup_item)
                        group_items[parentgroup_key] = parentgroup_item
                        group_menus[parentgroup_key] = parentgroup_submenu
                    
                    subgroup_name = subgroups[1]
                    item = build_emoji_item(emoji, subgroup_name)
                    submenu = build_group_menu(item)
                    GLib.idle_add(group_menus[parentgroup_key].append, item)
                else:
                    item = build_emoji_item(emoji, subgroup_name)
                    submenu = build_group_menu(item)
                    GLib.idle_add(group_menus[group_key].append, item)
				
                group_items[subgroup_key] = item
                group_menus[subgroup_key] = submenu
            
            # Check if emoji is part of a custom subgroup
            if emoji["hexcode"].lower() in subgroups_data["grouped_emojis"]: #TODO: implement setting
                parentgroup_index = str(subgroups_data["grouped_emojis"][emoji["hexcode"].lower()])
                parentgroup_name = subgroups_data["groups"][parentgroup_index]
                parentgroup_key = parentgroup_name + "-c"
                if parentgroup_key not in group_items:
                    parentgroup_item = build_emoji_item(emoji, parentgroup_name)
                    parentgroup_submenu = build_group_menu(parentgroup_item)
                    GLib.idle_add(group_menus[subgroup_key].append, parentgroup_item)
                    group_items[parentgroup_key] = parentgroup_item
                    group_menus[parentgroup_key] = parentgroup_submenu
                subgroup_key = parentgroup_key
            
            if "skins" not in emoji:
                # No skinned emoji, simply add it
                item = build_emoji_item(emoji)
                GLib.idle_add(group_menus[subgroup_key].append, item)
                signals[key] = item.connect("activate", item_response, emoji)
                
            else:
                # This emoji presents different skins, check for setting to see what to do
                if settings["toned"] == -1:
                    # Show all toned emojis in a submenu
                    item = build_emoji_item(emoji)
                    GLib.idle_add(group_menus[subgroup_key].append, item)
                    skin_submenu = build_group_menu(item)
                
                    # First, add the emoji without skin as subitem
                    item = build_emoji_item(emoji)
                    GLib.idle_add(skin_submenu.append, item)
                    # Then, add every skin a subitem
                    for skin in emoji["skins"]:
                        skin = fix_emoji_hexcode(skin)
                        skin_item = build_emoji_item(skin)
                        GLib.idle_add(skin_submenu.append, skin_item)
                        signals[key] = skin_item.connect("activate", item_response, skin)
                elif settings["toned"] == 0:
                    # Show only emoji without skin
                    item = build_emoji_item(emoji)
                    GLib.idle_add(group_menus[subgroup_key].append, item)
                    signals[key] = item.connect("activate", item_response, emoji)
                else:
                    # Show only emoji with selected skin type
                    for skin in emoji["skins"]:
                        if skin["tone"] == settings["toned"]:
                            skin = fix_emoji_hexcode(skin)
                            item = build_emoji_item(skin, get_emoji_name(emoji))
                            GLib.idle_add(group_menus[subgroup_key].append, item)
                            signals[key] = item.connect("activate", item_response, skin)
                            break
            
        # Load icons into recent category
        pixbuf = get_icon_pixbuf(directory + "/assets/categories/recent.svg")
        img = Gtk.Image.new_from_pixbuf(pixbuf)
        recent_item = build_menu_item("Recent", img)
        recent_menu = build_group_menu(recent_item)
        recent_items = []
        for i in range (0, settings["recent"]):
            recent_items.append(Gtk.ImageMenuItem())
            item_settings = recent_items[i].get_settings()
            item_settings.set_property('gtk-menu-images', True)
            GLib.idle_add(recent_menu.append, recent_items[i])
        refresh_recent_submenu()
        GLib.idle_add(menu.append, recent_item)
        
        # Create separator
        separator = Gtk.SeparatorMenuItem()
        GLib.idle_add(menu.append,separator)
        GLib.idle_add(separator.show)

        # Append categories to main menu
        for key in sorted(groups_data["groups"]):
            value = groups_data["groups"][key]
            GLib.idle_add(menu.append, group_items['0-' + value])
            GLib.idle_add(group_items['0-' + value].show)
            #TODO: add subgroups here ?! to support name sorting too

        # Create another separator
        separator = Gtk.SeparatorMenuItem()
        GLib.idle_add(menu.append,separator)
        GLib.idle_add(separator.show)

        # Create search item
        search_item = Gtk.MenuItem("Search Emoji")
        GLib.idle_add(menu.append,search_item)
        GLib.idle_add(search_item.show)
        search_item.connect("activate", open_search_window, "Search")

        # Create settings item
        settings_item = Gtk.MenuItem("Settings...")
        GLib.idle_add(menu.append,settings_item)
        GLib.idle_add(settings_item.show)    
        settings_item.connect("activate", open_settings_window, "Settings")
        
        # Create another separator
        separator = Gtk.SeparatorMenuItem()
        GLib.idle_add(menu.append,separator)
        GLib.idle_add(separator.show)

        # Create exit item
        exit_item = Gtk.MenuItem("Exit")
        GLib.idle_add(menu.append,exit_item)
        GLib.idle_add(exit_item.show)
        exit_item.connect("activate", exit, "Exit")

        # Associate menu with indicator
        ind.set_menu(menu)

        # Listen to socket
        try:
            os.unlink(sockname)
        except OSError:
            pass
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.bind(sockname)
            sock.listen(1)
            GLib.io_add_watch(sock, GLib.IO_IN, handle_sock_signal)
        except:
            print ('Could not listen to socket!')

        # Run server
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()
